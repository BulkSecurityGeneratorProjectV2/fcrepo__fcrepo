<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HttpIdentifierConverter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository HTTP API Module</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-http-commons</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.http.commons.api.rdf</a> &gt; <span class="el_source">HttpIdentifierConverter.java</span></div><h1>HttpIdentifierConverter.java</h1><pre class="source lang-java linenums">/*
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree.
 */
package org.fcrepo.http.commons.api.rdf;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.fcrepo.kernel.api.FedoraTypes.FEDORA_ID_PREFIX;
import static org.slf4j.LoggerFactory.getLogger;

import java.net.URLDecoder;
import java.util.HashMap;
import java.util.Map;

import javax.ws.rs.core.UriBuilder;

import org.fcrepo.kernel.api.identifiers.FedoraId;

import org.glassfish.jersey.uri.UriTemplate;
import org.slf4j.Logger;

/**
 * Convert between HTTP URIs (LDP paths) and internal Fedora ID using a
 * JAX-RS UriBuilder to mediate the URI translation.
 *
 * @author whikloj
 * @since 2019-09-26
 */
public class HttpIdentifierConverter {

<span class="fc" id="L32">    private static final Logger LOGGER = getLogger(HttpIdentifierConverter.class);</span>

    private final UriBuilder uriBuilder;

    private final UriTemplate uriTemplate;

    private static String trimTrailingSlashes(final String string) {
<span class="fc" id="L39">        return string.replaceAll(&quot;/+$&quot;, &quot;&quot;);</span>
    }

    /**
     * Create a new identifier converter with the given URI template.
     * @param uriBuilder the uri builder
     */
<span class="fc" id="L46">    public HttpIdentifierConverter(final UriBuilder uriBuilder) {</span>
<span class="fc" id="L47">        this.uriBuilder = uriBuilder;</span>
<span class="fc" id="L48">        this.uriTemplate = new UriTemplate(uriBuilder.toTemplate());</span>
<span class="fc" id="L49">    }</span>

    /**
     * Convert an external URI to an internal ID.
     *
     * @param httpUri the external URI.
     * @return the internal identifier.
     */
    public String toInternalId(final String httpUri) {
<span class="fc" id="L58">        return toInternalId(httpUri, false);</span>
    }

    /**
     * Convert an external URI to an internal ID.
     *
     * @param httpUri the external URI.
     * @param encoded whether the internal ID is encoded or not.
     * @return the internal identifier.
     */
    public String toInternalId(final String httpUri, final boolean encoded) {
<span class="fc" id="L69">        LOGGER.trace(&quot;Translating http URI {} to Fedora ID with encoded set to {}&quot;, httpUri, encoded);</span>

<span class="fc" id="L71">        final String path = getPath(httpUri);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (path != null) {</span>
            final String decodedPath;
<span class="fc bfc" id="L74" title="All 2 branches covered.">            if (!encoded) {</span>
<span class="fc" id="L75">                decodedPath = URLDecoder.decode(path, UTF_8);</span>
            } else {
<span class="fc" id="L77">                decodedPath = path;</span>
            }
<span class="fc" id="L79">            final String fedoraId = trimTrailingSlashes(decodedPath);</span>

<span class="fc" id="L81">            return FEDORA_ID_PREFIX + fedoraId;</span>
        }
<span class="fc" id="L83">        throw new IllegalArgumentException(&quot;Cannot translate NULL path extracted from URI &quot; + httpUri);</span>
    }

    /**
     * Test if the provided external URI is in the domain of this repository.
     *
     * If it is not in the domain we can't convert it.
     *
     * @param httpUri the external URI.
     * @return true if it is in domain.
     */
    public boolean inExternalDomain(final String httpUri) {
<span class="fc" id="L95">        LOGGER.trace(&quot;Checking if http URI {} is in domain&quot;, httpUri);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        return getPath(httpUri) != null;</span>
    }

    /**
     * Make a URI into an absolute URI (if relative), an internal encoded ID (if in repository domain) or leave it
     * alone.
     * @param httpUri the URI
     * @return an absolute URI, the original URI or an internal ID.
     */
    public String translateUri(final String httpUri) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (inExternalDomain(httpUri)) {</span>
<span class="fc" id="L107">            return toInternalId(httpUri, true);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        } else if (httpUri.startsWith(&quot;/&quot;)) {</span>
            // Is a relative URI.
            // Build a fake URI using the hostname so we can resolve against it.
<span class="nc" id="L111">            final var uri = uriBuilder.build(&quot;placeholder&quot;);</span>
<span class="nc" id="L112">            return uri.resolve(httpUri).toString();</span>
        }
<span class="fc" id="L114">        return httpUri;</span>
    }

    /**
     * Convert an internal identifier to an external URI.
     *
     * @param fedoraId the internal identifier.
     * @return the external URI.
     */
    public String toExternalId(final String fedoraId) {
<span class="fc" id="L124">        LOGGER.trace(&quot;Translating Fedora ID {} to Http URI&quot;, fedoraId);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (inInternalDomain(fedoraId)) {</span>
            // If it starts with our prefix, strip the prefix and any leading slashes and use it as the path
            // part of the URI.
<span class="fc" id="L128">            final String path = fedoraId.substring(FEDORA_ID_PREFIX.length()).replaceFirst(&quot;/&quot;, &quot;&quot;);</span>
<span class="fc" id="L129">            return buildUri(path);</span>
        }
<span class="fc" id="L131">        throw new IllegalArgumentException(&quot;Cannot translate IDs without our prefix&quot;);</span>
    }

    /**
     * Check if the provided internal identifier is in the domain of the repository.
     *
     * If it is not in the domain we can't convert it.
     *
     * @param fedoraId the internal identifier.
     * @return true if it is in domain.
     */
    public boolean inInternalDomain(final String fedoraId) {
<span class="fc" id="L143">        LOGGER.trace(&quot;Checking if fedora ID {} is in domain&quot;, fedoraId);</span>
<span class="fc" id="L144">        return (fedoraId.startsWith(FEDORA_ID_PREFIX));</span>
    }

    /**
     * Return a UriBuilder for the current template.
     *
     * @return the uri builder.
     */
    private UriBuilder uriBuilder() {
<span class="fc" id="L153">        return UriBuilder.fromUri(uriBuilder.toTemplate());</span>
    }

    /**
     * Convert a path to a full url using the UriBuilder template.
     * @param path the external path.
     * @return the full url.
     */
    public String toDomain(final String path) {

        final String realPath;
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (path == null) {</span>
<span class="nc" id="L165">            realPath = &quot;&quot;;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        } else if (path.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L167">            realPath = path.substring(1);</span>
        } else {
<span class="fc" id="L169">            realPath = path;</span>
        }

<span class="fc" id="L172">        return buildUri(realPath);</span>
    }

    /**
     * Function to convert from the external path of a URI to an internal FedoraId.
     * @param externalPath the path part of the external URI.
     * @return the FedoraId.
     */
    public FedoraId pathToInternalId(final String externalPath) {
<span class="fc" id="L181">        return FedoraId.create(externalPath);</span>
    }

    /**
     * Utility to build a URL.
     * @param path the path from the internal Id.
     * @return an external URI.
     */
    private String buildUri(final String path) {
<span class="fc" id="L190">        final UriBuilder uri = uriBuilder();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (path.contains(&quot;#&quot;)) {</span>
<span class="fc" id="L192">            final String[] split = path.split(&quot;#&quot;, 2);</span>
<span class="fc" id="L193">            uri.resolveTemplateFromEncoded(&quot;path&quot;, split[0]);</span>
<span class="fc" id="L194">            uri.fragment(split[1]);</span>
<span class="fc" id="L195">        } else {</span>
<span class="fc" id="L196">            uri.resolveTemplateFromEncoded(&quot;path&quot;, path);</span>
        }
<span class="fc" id="L198">        return uri.build().toString();</span>
    }

    /**
     * Split the path off the URI.
     *
     * @param httpUri the incoming URI.
     * @return the path of the URI.
     */
    private String getPath(final String httpUri) {
<span class="fc" id="L208">        final Map&lt;String, String&gt; values = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L210" title="1 of 4 branches missed.">        if (uriTemplate.match(httpUri, values) &amp;&amp; values.containsKey(&quot;path&quot;)) {</span>
<span class="fc" id="L211">            return &quot;/&quot; + values.get(&quot;path&quot;);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        } else if (isRootWithoutTrailingSlash(httpUri)) {</span>
<span class="fc" id="L213">            return &quot;/&quot;;</span>
        }
<span class="fc" id="L215">        return null;</span>
    }

    /**
     * Test if the URI is the root but missing the trailing slash
     *
     * @param httpUri the incoming URI.
     * @return whether or not it is the root minus trailing slash
     */
    private boolean isRootWithoutTrailingSlash(final String httpUri) {
<span class="fc" id="L225">        final Map&lt;String, String&gt; values = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L227" title="1 of 4 branches missed.">        return uriTemplate.match(httpUri + &quot;/&quot;, values) &amp;&amp; values.containsKey(&quot;path&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">            values.get(&quot;path&quot;).isEmpty();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>