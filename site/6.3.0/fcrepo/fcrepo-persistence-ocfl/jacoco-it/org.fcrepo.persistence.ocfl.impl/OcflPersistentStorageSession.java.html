<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OcflPersistentStorageSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository OCFL Persistence Impl</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.persistence.ocfl.impl</a> &gt; <span class="el_source">OcflPersistentStorageSession.java</span></div><h1>OcflPersistentStorageSession.java</h1><pre class="source lang-java linenums">/*
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree.
 */
package org.fcrepo.persistence.ocfl.impl;

import static java.lang.String.format;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.apache.jena.graph.NodeFactory.createURI;
import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;

import java.io.IOException;
import java.io.InputStream;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;

import org.fcrepo.kernel.api.RdfStream;
import org.fcrepo.kernel.api.Transaction;
import org.fcrepo.kernel.api.identifiers.FedoraId;
import org.fcrepo.kernel.api.models.ResourceHeaders;
import org.fcrepo.kernel.api.operations.ResourceOperation;
import org.fcrepo.kernel.api.rdf.DefaultRdfStream;
import org.fcrepo.persistence.api.PersistentStorageSession;
import org.fcrepo.persistence.api.exceptions.PersistentItemNotFoundException;
import org.fcrepo.persistence.api.exceptions.PersistentSessionClosedException;
import org.fcrepo.persistence.api.exceptions.PersistentStorageException;
import org.fcrepo.persistence.ocfl.api.FedoraOcflMappingNotFoundException;
import org.fcrepo.persistence.ocfl.api.FedoraToOcflObjectIndex;
import org.fcrepo.persistence.ocfl.api.Persister;
import org.fcrepo.storage.ocfl.OcflObjectSession;
import org.fcrepo.storage.ocfl.OcflObjectSessionFactory;
import org.fcrepo.storage.ocfl.OcflVersionInfo;

import org.apache.jena.rdf.model.Model;
import org.apache.jena.riot.RDFDataMgr;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * OCFL Persistent Storage class.
 *
 * @author whikloj
 * @since 2019-09-20
 */
public class OcflPersistentStorageSession implements PersistentStorageSession {

<span class="fc" id="L60">    private static final Logger LOGGER = LoggerFactory.getLogger(OcflPersistentStorageSession.class);</span>

    private static final long AWAIT_TIMEOUT = 30000L;

    /**
     * Externally generated Transaction for the session.
     */
    private final Transaction transaction;

    private final FedoraToOcflObjectIndex fedoraOcflIndex;

    private final Map&lt;String, OcflObjectSession&gt; sessionMap;

    private final ReindexService reindexSerivce;

    private Map&lt;String, OcflObjectSession&gt; sessionsToRollback;

<span class="fc" id="L77">    private final Phaser phaser = new Phaser();</span>

<span class="fc" id="L79">    private final List&lt;Persister&gt; persisterList = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L81">    private State state = State.COMMIT_NOT_STARTED;</span>

    private final OcflObjectSessionFactory objectSessionFactory;

<span class="fc" id="L85">    private enum State {</span>
<span class="fc" id="L86">        COMMIT_NOT_STARTED(true),</span>
<span class="fc" id="L87">        PREPARE_STARTED(false),</span>
<span class="fc" id="L88">        PREPARED(true),</span>
<span class="fc" id="L89">        PREPARE_FAILED(true),</span>
<span class="fc" id="L90">        COMMIT_STARTED(false),</span>
<span class="fc" id="L91">        COMMITTED(true),</span>
<span class="fc" id="L92">        COMMIT_FAILED(true),</span>
<span class="fc" id="L93">        ROLLING_BACK(false),</span>
<span class="fc" id="L94">        ROLLED_BACK(false),</span>
<span class="fc" id="L95">        ROLLBACK_FAILED(false);</span>

        final boolean rollbackAllowed;

<span class="fc" id="L99">        State(final boolean rollbackAllowed) {</span>
<span class="fc" id="L100">            this.rollbackAllowed = rollbackAllowed;</span>
<span class="fc" id="L101">        }</span>

    }

    /**
     * Constructor
     *
     * @param tx                   the transaction.
     * @param fedoraOcflIndex      the index
     * @param objectSessionFactory the session factory
     */
    protected OcflPersistentStorageSession(final Transaction tx,
                                           final FedoraToOcflObjectIndex fedoraOcflIndex,
                                           final OcflObjectSessionFactory objectSessionFactory,
<span class="fc" id="L115">                                           final ReindexService reindexService) {</span>
<span class="fc" id="L116">        this.transaction = tx;</span>
<span class="fc" id="L117">        this.fedoraOcflIndex = fedoraOcflIndex;</span>
<span class="fc" id="L118">        this.objectSessionFactory = objectSessionFactory;</span>
<span class="fc" id="L119">        this.reindexSerivce = reindexService;</span>
<span class="fc" id="L120">        this.sessionsToRollback = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (!tx.isReadOnly()) {</span>
<span class="fc" id="L123">            this.sessionMap = new ConcurrentHashMap&lt;&gt;();</span>
        } else {
            // The read-only session is never closed, so it needs to periodically expire object sessions
<span class="fc" id="L126">            this.sessionMap = Caffeine.newBuilder()</span>
<span class="fc" id="L127">                    .maximumSize(512)</span>
<span class="fc" id="L128">                    .expireAfterAccess(10, TimeUnit.MINUTES)</span>
<span class="fc" id="L129">                    .&lt;String, OcflObjectSession&gt;build()</span>
<span class="fc" id="L130">                    .asMap();</span>
        }

        //load the persister list if empty
<span class="fc" id="L134">        persisterList.add(new CreateRdfSourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L135">        persisterList.add(new UpdateRdfSourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L136">        persisterList.add(new UpdateNonRdfSourceHeadersPersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L137">        persisterList.add(new CreateNonRdfSourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L138">        persisterList.add(new UpdateNonRdfSourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L139">        persisterList.add(new DeleteResourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L140">        persisterList.add(new CreateVersionPersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L141">        persisterList.add(new PurgeResourcePersister(this.fedoraOcflIndex));</span>
<span class="fc" id="L142">        persisterList.add(new ReindexResourcePersister(this.reindexSerivce));</span>

<span class="fc" id="L144">    }</span>

    @Override
    public String getId() {
<span class="nc" id="L148">        return this.transaction.getId();</span>
    }

    @Override
    public void persist(final ResourceOperation operation) throws PersistentStorageException {
<span class="fc" id="L153">        actionNeedsWrite();</span>
<span class="fc" id="L154">        ensureCommitNotStarted();</span>

        try {
<span class="fc" id="L157">            phaser.register();</span>

            //resolve the persister based on the operation
<span class="fc" id="L160">            final var persister = persisterList.stream().filter(p -&gt; p.handle(operation)).findFirst().orElse(null);</span>

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            if (persister == null) {</span>
<span class="nc" id="L163">                throw new UnsupportedOperationException(format(&quot;The %s is not yet supported&quot;, operation.getClass()));</span>
            }

            //perform the operation
<span class="fc" id="L167">            persister.persist(this, operation);</span>

        } finally {
<span class="fc" id="L170">            phaser.arriveAndDeregister();</span>
        }

<span class="fc" id="L173">    }</span>

    private void ensureCommitNotStarted() throws PersistentSessionClosedException {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (!state.equals(State.COMMIT_NOT_STARTED)) {</span>
<span class="nc" id="L177">            throw new PersistentSessionClosedException(</span>
<span class="nc" id="L178">                    String.format(&quot;Storage session %s is already closed&quot;, transaction));</span>
        }
<span class="fc" id="L180">    }</span>

    private void ensurePrepared() throws PersistentSessionClosedException {
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (!state.equals(State.PREPARED)) {</span>
<span class="nc" id="L184">            throw new PersistentStorageException(</span>
<span class="nc" id="L185">                    String.format(&quot;Storage session %s cannot be committed because it is not in the correct state: %s&quot;,</span>
                            transaction, state));
        }
<span class="fc" id="L188">    }</span>

    OcflObjectSession findOrCreateSession(final String ocflId) {
<span class="fc" id="L191">        return this.sessionMap.computeIfAbsent(ocflId, key -&gt; {</span>
<span class="fc" id="L192">            return new FcrepoOcflObjectSessionWrapper(this.objectSessionFactory.newSession(key));</span>
        });
    }

    @Override
    public ResourceHeaders getHeaders(final FedoraId identifier, final Instant version)
            throws PersistentStorageException {
<span class="fc" id="L199">        ensureCommitNotStarted();</span>

<span class="fc" id="L201">        final FedoraOcflMapping mapping = getFedoraOcflMapping(identifier);</span>
<span class="fc" id="L202">        final OcflObjectSession objSession = findOrCreateSession(mapping.getOcflObjectId());</span>

<span class="fc" id="L204">        final var versionId = resolveVersionNumber(objSession, identifier, version);</span>
<span class="fc" id="L205">        final var headers = objSession.readHeaders(identifier.getResourceId(), versionId);</span>

<span class="fc" id="L207">        return new ResourceHeadersAdapter(headers).asKernelHeaders();</span>
    }

    private FedoraOcflMapping getFedoraOcflMapping(final FedoraId identifier)
            throws PersistentStorageException {
        try {
<span class="fc" id="L213">            return fedoraOcflIndex.getMapping(transaction, identifier);</span>
<span class="fc" id="L214">        } catch (final FedoraOcflMappingNotFoundException e) {</span>
<span class="fc" id="L215">            throw new PersistentItemNotFoundException(String.format(&quot;Resource %s not found&quot;,</span>
<span class="fc" id="L216">                    identifier.getFullIdPath()), e);</span>
        }
    }

    @Override
    public RdfStream getTriples(final FedoraId identifier, final Instant version)
            throws PersistentStorageException {
<span class="nc" id="L223">        ensureCommitNotStarted();</span>

<span class="nc" id="L225">        LOGGER.debug(&quot;Getting triples for {} at {}&quot;, identifier, version);</span>

<span class="nc" id="L227">        try (final InputStream is = getBinaryContent(identifier, version)) {</span>
<span class="nc" id="L228">            final Model model = createDefaultModel();</span>
<span class="nc" id="L229">            RDFDataMgr.read(model, is, OcflPersistentStorageUtils.getRdfFormat().getLang());</span>
<span class="nc" id="L230">            final FedoraId topic = resolveTopic(identifier);</span>
<span class="nc" id="L231">            return DefaultRdfStream.fromModel(createURI(topic.getFullId()), model);</span>
<span class="nc" id="L232">        } catch (final IOException ex) {</span>
<span class="nc" id="L233">            throw new PersistentStorageException(format(&quot;unable to read %s ;  version = %s&quot;, identifier, version), ex);</span>
        }
    }

    @Override
    public List&lt;Instant&gt; listVersions(final FedoraId fedoraIdentifier)
            throws PersistentStorageException {
<span class="nc" id="L240">        final var mapping = getFedoraOcflMapping(fedoraIdentifier);</span>
<span class="nc" id="L241">        final var objSession = findOrCreateSession(mapping.getOcflObjectId());</span>

<span class="nc" id="L243">        return objSession.listVersions(fedoraIdentifier.getResourceId()).stream()</span>
<span class="nc" id="L244">                .map(OcflVersionInfo::getCreated)</span>
<span class="nc" id="L245">                .collect(Collectors.toList());</span>
    }

    @Override
    public InputStream getBinaryContent(final FedoraId identifier, final Instant version)
            throws PersistentStorageException {
<span class="fc" id="L251">        ensureCommitNotStarted();</span>

<span class="fc" id="L253">        final var mapping = getFedoraOcflMapping(identifier);</span>
<span class="fc" id="L254">        final var objSession = findOrCreateSession(mapping.getOcflObjectId());</span>

<span class="fc" id="L256">        final var versionNumber = resolveVersionNumber(objSession, identifier, version);</span>

<span class="fc" id="L258">        return objSession.readContent(identifier.getResourceId(), versionNumber)</span>
<span class="fc" id="L259">                .getContentStream()</span>
<span class="fc" id="L260">                .orElseThrow(() -&gt; new PersistentItemNotFoundException(&quot;No binary content found for resource &quot;</span>
<span class="fc" id="L261">                        + identifier.getFullId()));</span>
    }

    @Override
    public synchronized void prepare() {
<span class="fc" id="L266">        ensureCommitNotStarted();</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (isReadOnly()) {</span>
            // No changes to commit.
<span class="nc" id="L269">            return;</span>
        }

<span class="fc" id="L272">        this.state = State.PREPARE_STARTED;</span>
<span class="fc" id="L273">        LOGGER.debug(&quot;Starting storage session {} prepare for commit&quot;, transaction);</span>

<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (this.phaser.getRegisteredParties() &gt; 0) {</span>
<span class="nc" id="L276">            this.phaser.awaitAdvance(0);</span>
        }

<span class="fc" id="L279">        LOGGER.trace(&quot;All persisters are complete in session {}&quot;, transaction);</span>

        try {
<span class="fc" id="L282">            fedoraOcflIndex.commit(transaction);</span>
<span class="fc" id="L283">            state = State.PREPARED;</span>
<span class="nc" id="L284">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L285">            state = State.PREPARE_FAILED;</span>
<span class="nc" id="L286">            throw new PersistentStorageException(String.format(&quot;Failed to prepare storage session &lt;%s&gt; for commit&quot;,</span>
                    transaction), e);
<span class="fc" id="L288">        }</span>
<span class="fc" id="L289">    }</span>

    @Override
    public synchronized void commit() throws PersistentStorageException {
<span class="fc" id="L293">        ensurePrepared();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (isReadOnly()) {</span>
            // No changes to commit.
<span class="nc" id="L296">            return;</span>
        }

<span class="fc" id="L299">        this.state = State.COMMIT_STARTED;</span>
<span class="fc" id="L300">        LOGGER.debug(&quot;Starting storage session {} commit&quot;, transaction);</span>

        // order map for testing
<span class="fc" id="L303">        final var sessions = new TreeMap&lt;&gt;(sessionMap);</span>
<span class="fc" id="L304">        commitObjectSessions(sessions);</span>

<span class="fc" id="L306">        LOGGER.debug(&quot;Committed storage session {}&quot;, transaction);</span>
<span class="fc" id="L307">    }</span>

    private void commitObjectSessions(final Map&lt;String, OcflObjectSession&gt; sessions)
            throws PersistentStorageException {
<span class="fc" id="L311">        this.sessionsToRollback = new HashMap&lt;&gt;(sessionMap.size());</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (final var entry : sessions.entrySet()) {</span>
<span class="fc" id="L314">            final var id = entry.getKey();</span>
<span class="fc" id="L315">            final var session = entry.getValue();</span>
            try {
<span class="fc" id="L317">                session.commit();</span>
<span class="fc" id="L318">                sessionsToRollback.put(id, session);</span>
<span class="fc" id="L319">            } catch (final Exception e) {</span>
<span class="fc" id="L320">                this.state = State.COMMIT_FAILED;</span>
<span class="fc" id="L321">                throw new PersistentStorageException(String.format(&quot;Failed to commit object &lt;%s&gt; in session &lt;%s&gt;&quot;,</span>
                        id, transaction), e);
<span class="fc" id="L323">            }</span>
<span class="fc" id="L324">        }</span>

<span class="fc" id="L326">        state = State.COMMITTED;</span>
<span class="fc" id="L327">    }</span>

    @Override
    public void rollback() throws PersistentStorageException {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (isReadOnly()) {</span>
            // No changes to rollback
<span class="nc" id="L333">            return;</span>
        }

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (!state.rollbackAllowed) {</span>
<span class="nc" id="L337">            throw new PersistentStorageException(&quot;This session cannot be rolled back in this state: &quot; + state);</span>
        }

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        final boolean commitWasStarted = this.state != State.COMMIT_NOT_STARTED;</span>

<span class="fc" id="L342">        this.state = State.ROLLING_BACK;</span>
<span class="fc" id="L343">        LOGGER.debug(&quot;Rolling back storage session {}&quot;, transaction);</span>

<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (!commitWasStarted) {</span>
            //if the commit had not been started at the time this method was invoked
            //we must ensure that all persist operations are complete before we close any
            //ocfl object sessions. If the commit had been started then this synchronization step
            //will have already occurred and is thus unnecessary.
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (this.phaser.getRegisteredParties() &gt; 0) {</span>
                try {
<span class="nc" id="L352">                    this.phaser.awaitAdvanceInterruptibly(0, AWAIT_TIMEOUT, MILLISECONDS);</span>
<span class="nc" id="L353">                } catch (final InterruptedException | TimeoutException e) {</span>
<span class="nc" id="L354">                    throw new PersistentStorageException(</span>
                            &quot;Waiting for operations to complete took too long, rollback failed&quot;);
<span class="nc" id="L356">                }</span>
            }
        }

<span class="fc" id="L360">        closeUncommittedSessions();</span>

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (commitWasStarted) {</span>
<span class="nc" id="L363">            rollbackCommittedSessions();</span>
        }

<span class="fc" id="L366">        this.state = State.ROLLED_BACK;</span>
<span class="fc" id="L367">        LOGGER.trace(&quot;Successfully rolled back storage session {}&quot;, transaction);</span>
<span class="fc" id="L368">    }</span>

    /**
     * Resolve an instant to a version
     *
     * @param objSession session
     * @param fedoraId the FedoraId of the resource
     * @param version version time
     * @return name of version
     * @throws PersistentStorageException thrown if version not found
     */
    private String resolveVersionNumber(final OcflObjectSession objSession,
                                       final FedoraId fedoraId,
                                       final Instant version)
            throws PersistentStorageException {
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (version != null) {</span>
<span class="nc" id="L384">            final var versions = objSession.listVersions(fedoraId.getResourceId());</span>
            // reverse order so that the most recent version is matched first
<span class="nc" id="L386">            Collections.reverse(versions);</span>
<span class="nc" id="L387">            return versions.stream()</span>
<span class="nc" id="L388">                    .filter(vd -&gt; vd.getCreated().equals(version))</span>
<span class="nc" id="L389">                    .map(OcflVersionInfo::getVersionNumber)</span>
<span class="nc" id="L390">                    .findFirst()</span>
<span class="nc" id="L391">                    .orElseThrow(() -&gt; {</span>
<span class="nc" id="L392">                        return new PersistentItemNotFoundException(format(</span>
                                &quot;There is no version in %s with a created date matching %s&quot;,
                                fedoraId, version));
                    });
        }

<span class="fc" id="L398">        return null;</span>
    }

    private void closeUncommittedSessions() {
<span class="fc" id="L402">        this.sessionMap.entrySet().stream()</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                .filter(entry -&gt; !sessionsToRollback.containsKey(entry.getKey()))</span>
<span class="fc" id="L404">                .map(Map.Entry::getValue)</span>
<span class="fc" id="L405">                .forEach(OcflObjectSession::abort);</span>
<span class="fc" id="L406">    }</span>

    private void rollbackCommittedSessions() throws PersistentStorageException {
<span class="nc" id="L409">        final List&lt;String&gt; rollbackFailures = new ArrayList&lt;&gt;(this.sessionsToRollback.size());</span>

<span class="nc bnc" id="L411" title="All 2 branches missed.">        for (final var entry : this.sessionsToRollback.entrySet()) {</span>
<span class="nc" id="L412">            final var id = entry.getKey();</span>
<span class="nc" id="L413">            final var session = entry.getValue();</span>

            try {
<span class="nc" id="L416">                session.rollback();</span>
<span class="nc" id="L417">            } catch (final Exception e) {</span>
<span class="nc" id="L418">                rollbackFailures.add(String.format(&quot;Failed to rollback object &lt;%s&gt; in session &lt;%s&gt;: %s&quot;,</span>
<span class="nc" id="L419">                        id, session.sessionId(), e.getMessage()));</span>
<span class="nc" id="L420">            }</span>
<span class="nc" id="L421">        }</span>

        try {
<span class="nc" id="L424">            fedoraOcflIndex.rollback(transaction);</span>
<span class="nc" id="L425">        } catch (final Exception e) {</span>
<span class="nc" id="L426">            rollbackFailures.add(String.format(&quot;Failed to rollback OCFL index updates in transaction &lt;%s&gt;: %s&quot;,</span>
<span class="nc" id="L427">                    transaction, e.getMessage()));</span>
<span class="nc" id="L428">        }</span>

        //throw an exception if any sessions could not be rolled back.
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (rollbackFailures.size() &gt; 0) {</span>
<span class="nc" id="L432">            state = State.ROLLBACK_FAILED;</span>
<span class="nc" id="L433">            final StringBuilder builder = new StringBuilder()</span>
<span class="nc" id="L434">                    .append(&quot;Unable to rollback storage session &quot;)</span>
<span class="nc" id="L435">                    .append(transaction)</span>
<span class="nc" id="L436">                    .append(&quot; completely due to the following errors: \n&quot;);</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (final String failures : rollbackFailures) {</span>
<span class="nc" id="L439">                builder.append(&quot;\t&quot;).append(failures).append(&quot;\n&quot;);</span>
<span class="nc" id="L440">            }</span>

<span class="nc" id="L442">            throw new PersistentStorageException(builder.toString());</span>
        }
<span class="nc" id="L444">    }</span>

    /**
     * Check if we are in a read-only session.
     *
     * @return whether we are read-only (ie. no transaction).
     */
    private boolean isReadOnly() {
<span class="fc" id="L452">        return this.transaction.isReadOnly();</span>
    }

    /**
     * Utility to throw exception if trying to perform write operation on read-only session.
     */
    private void actionNeedsWrite() throws PersistentStorageException {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (isReadOnly()) {</span>
<span class="nc" id="L460">            throw new PersistentStorageException(&quot;Session is read-only&quot;);</span>
        }
<span class="fc" id="L462">    }</span>

    /**
     * Returns the RDF topic to be returned for a given resource identifier
     * For example:  passing info:fedora/resource1/fcr:metadata would return
     *  info:fedora/resource1 since  info:fedora/resource1 would be the expected
     *  topic.
     * @param fedoraIdentifier The fedora identifier
     * @return The resolved topic
     */
    private FedoraId resolveTopic(final FedoraId fedoraIdentifier) {
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (fedoraIdentifier.isDescription()) {</span>
<span class="nc" id="L474">            return fedoraIdentifier.asBaseId();</span>
        } else {
<span class="nc" id="L476">            return fedoraIdentifier;</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L482">        return &quot;OcflPersistentStorageSession{&quot; +</span>
                &quot;sessionId='&quot; + transaction + '\'' +
                &quot;, state=&quot; + state +
                '}';
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>