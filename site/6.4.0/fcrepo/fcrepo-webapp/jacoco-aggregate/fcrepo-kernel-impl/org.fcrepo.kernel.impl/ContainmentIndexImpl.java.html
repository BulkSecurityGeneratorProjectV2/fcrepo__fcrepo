<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ContainmentIndexImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Fedora Repository Deployable Web Application</a> &gt; <a href="../index.html" class="el_bundle">fcrepo-kernel-impl</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.kernel.impl</a> &gt; <span class="el_source">ContainmentIndexImpl.java</span></div><h1>ContainmentIndexImpl.java</h1><pre class="source lang-java linenums">/*
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree.
 */
package org.fcrepo.kernel.impl;

import static org.fcrepo.kernel.api.FedoraTypes.FEDORA_ID_PREFIX;
import static org.slf4j.LoggerFactory.getLogger;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.annotation.Nonnull;
import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;

import org.fcrepo.common.db.DbPlatform;
import org.fcrepo.config.FedoraPropsConfig;
import org.fcrepo.kernel.api.ContainmentIndex;
import org.fcrepo.kernel.api.Transaction;
import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;
import org.fcrepo.kernel.api.identifiers.FedoraId;

import org.slf4j.Logger;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * @author peichman
 * @author whikloj
 * @since 6.0.0
 */
@Component(&quot;containmentIndexImpl&quot;)
<span class="nc" id="L56">public class ContainmentIndexImpl implements ContainmentIndex {</span>

<span class="nc" id="L58">    private static final Logger LOGGER = getLogger(ContainmentIndexImpl.class);</span>

<span class="nc" id="L60">    private int containsLimit = 50000;</span>

    @Inject
    private DataSource dataSource;

    private NamedParameterJdbcTemplate jdbcTemplate;

    private DbPlatform dbPlatform;

    public static final String RESOURCES_TABLE = &quot;containment&quot;;

    private static final String TRANSACTION_OPERATIONS_TABLE = &quot;containment_transactions&quot;;

    public static final String FEDORA_ID_COLUMN = &quot;fedora_id&quot;;

    private static final String PARENT_COLUMN = &quot;parent&quot;;

    private static final String TRANSACTION_ID_COLUMN = &quot;transaction_id&quot;;

    private static final String OPERATION_COLUMN = &quot;operation&quot;;

    private static final String START_TIME_COLUMN = &quot;start_time&quot;;

    private static final String END_TIME_COLUMN = &quot;end_time&quot;;

    private static final String UPDATED_COLUMN = &quot;updated&quot;;

    /*
     * Select children of a resource that are not marked as deleted.
     */
    private static final String SELECT_CHILDREN = &quot;SELECT &quot; + FEDORA_ID_COLUMN +
            &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + END_TIME_COLUMN + &quot; IS NULL&quot; +
            &quot; ORDER BY &quot; + FEDORA_ID_COLUMN + &quot; LIMIT :containsLimit OFFSET :offSet&quot;;

    /*
     * Select children of a memento of a resource.
     */
    private static final String SELECT_CHILDREN_OF_MEMENTO = &quot;SELECT &quot; + FEDORA_ID_COLUMN +
            &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + START_TIME_COLUMN +
            &quot; &lt;= :asOfTime AND (&quot; + END_TIME_COLUMN + &quot; &gt; :asOfTime OR &quot; + END_TIME_COLUMN + &quot; IS NULL) ORDER BY &quot; +
            FEDORA_ID_COLUMN + &quot; LIMIT :containsLimit OFFSET :offSet&quot;;

    /*
     * Select children of a parent from resources table and from the transaction table with an 'add' operation,
     * but exclude any records that also exist in the transaction table with a 'delete' or 'purge' operation.
     */
    private static final String SELECT_CHILDREN_IN_TRANSACTION = &quot;SELECT x.&quot; + FEDORA_ID_COLUMN + &quot; FROM&quot; +
            &quot; (SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent&quot; +
            &quot; AND &quot; + END_TIME_COLUMN + &quot; IS NULL &quot; +
            &quot; UNION SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot; +
            &quot; AND &quot; + OPERATION_COLUMN + &quot; = 'add') x&quot; +
            &quot; WHERE NOT EXISTS &quot; +
            &quot; (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + FEDORA_ID_COLUMN + &quot; = x.&quot; + FEDORA_ID_COLUMN +
            &quot; AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; IN ('delete', 'purge'))&quot; +
            &quot; ORDER BY x.&quot; + FEDORA_ID_COLUMN + &quot; LIMIT :containsLimit OFFSET :offSet&quot;;

    /*
     * Select all children of a resource that are marked for deletion.
     */
    private static final String SELECT_DELETED_CHILDREN = &quot;SELECT &quot; + FEDORA_ID_COLUMN +
            &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + END_TIME_COLUMN +
            &quot; IS NOT NULL ORDER BY &quot; + FEDORA_ID_COLUMN + &quot; LIMIT :containsLimit OFFSET :offSet&quot;;

    /*
     * Select children of a resource plus children 'delete'd in the non-committed transaction, but excluding any
     * 'add'ed in the non-committed transaction.
     */
    private static final String SELECT_DELETED_CHILDREN_IN_TRANSACTION = &quot;SELECT x.&quot; + FEDORA_ID_COLUMN +
            &quot; FROM (SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + END_TIME_COLUMN + &quot; IS NOT NULL UNION&quot; +
            &quot; SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; +
            PARENT_COLUMN + &quot; = :parent AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'delete') x&quot; +
            &quot; WHERE NOT EXISTS &quot; +
            &quot;(SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; +
            FEDORA_ID_COLUMN + &quot; = x.&quot; + FEDORA_ID_COLUMN + &quot; AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'add') ORDER BY x.&quot; + FEDORA_ID_COLUMN + &quot; LIMIT :containsLimit OFFSET :offSet&quot;;

    /*
     * Upsert a parent child relationship to the transaction operation table.
     */
    private static final String UPSERT_RECORDS_POSTGRESQL = &quot;INSERT INTO &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; ( &quot; + PARENT_COLUMN + &quot;, &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;, &quot; +
            TRANSACTION_ID_COLUMN + &quot;, &quot; + OPERATION_COLUMN + &quot;) VALUES (:parent, :child, :startTime, :endTime, &quot; +
            &quot;:transactionId, :operation) ON CONFLICT ( &quot; +  FEDORA_ID_COLUMN + &quot;, &quot; + TRANSACTION_ID_COLUMN + &quot;) &quot; +
            &quot;DO UPDATE SET &quot; + PARENT_COLUMN + &quot; = EXCLUDED.&quot; + PARENT_COLUMN + &quot;, &quot; +
            START_TIME_COLUMN + &quot; = EXCLUDED.&quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot; = EXCLUDED.&quot; +
            END_TIME_COLUMN + &quot;, &quot; + OPERATION_COLUMN + &quot; = EXCLUDED.&quot; + OPERATION_COLUMN;

    private static final String UPSERT_RECORDS_MYSQL_MARIA = &quot;INSERT INTO &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; (&quot; + PARENT_COLUMN + &quot;, &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;, &quot; +
            TRANSACTION_ID_COLUMN + &quot;, &quot; + OPERATION_COLUMN + &quot;) VALUES (:parent, :child, :startTime, :endTime, &quot; +
            &quot;:transactionId, :operation) ON DUPLICATE KEY UPDATE &quot; +
            PARENT_COLUMN + &quot; = VALUES(&quot; + PARENT_COLUMN + &quot;), &quot; + START_TIME_COLUMN + &quot; = VALUES(&quot; +
            START_TIME_COLUMN + &quot;), &quot; + END_TIME_COLUMN + &quot; = VALUES(&quot; + END_TIME_COLUMN + &quot;), &quot; + OPERATION_COLUMN +
            &quot; = VALUES(&quot; + OPERATION_COLUMN + &quot;)&quot;;

    private static final String UPSERT_RECORDS_H2 = &quot;MERGE INTO &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; (&quot; + PARENT_COLUMN + &quot;, &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;, &quot; +
            TRANSACTION_ID_COLUMN + &quot;, &quot; + OPERATION_COLUMN + &quot;) KEY (&quot; + FEDORA_ID_COLUMN + &quot;, &quot; +
            TRANSACTION_ID_COLUMN + &quot;) VALUES (:parent, :child, :startTime, :endTime, :transactionId, :operation)&quot;;

    private static final String DIRECT_UPDATE_END_TIME = &quot;UPDATE &quot; + RESOURCES_TABLE +
            &quot; SET &quot; + END_TIME_COLUMN + &quot; = :endTime WHERE &quot; +
            PARENT_COLUMN + &quot; = :parent AND &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot;;

<span class="nc" id="L168">    private static final Map&lt;DbPlatform, String&gt; UPSERT_MAPPING = Map.of(</span>
            DbPlatform.H2, UPSERT_RECORDS_H2,
            DbPlatform.MYSQL, UPSERT_RECORDS_MYSQL_MARIA,
            DbPlatform.MARIADB, UPSERT_RECORDS_MYSQL_MARIA,
            DbPlatform.POSTGRESQL, UPSERT_RECORDS_POSTGRESQL
    );

    private static final String DIRECT_INSERT_RECORDS = &quot;INSERT INTO &quot; + RESOURCES_TABLE +
            &quot; (&quot; + PARENT_COLUMN + &quot;, &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;)&quot; +
            &quot; VALUES (:parent, :child, :startTime, :endTime)&quot;;

    private static final String DIRECT_INSERT_POSTGRESQL = &quot; ON CONFLICT ( &quot; + FEDORA_ID_COLUMN + &quot;)&quot; +
            &quot;DO UPDATE SET &quot; + PARENT_COLUMN + &quot; = EXCLUDED.&quot; + PARENT_COLUMN + &quot;, &quot; +
            START_TIME_COLUMN + &quot; = EXCLUDED.&quot; + START_TIME_COLUMN + &quot;, &quot; +
            END_TIME_COLUMN + &quot; = EXCLUDED.&quot; + END_TIME_COLUMN;

    private static final String DIRECT_INSERT_MYSQL_MARIA = &quot; ON DUPLICATE KEY UPDATE &quot; +
            PARENT_COLUMN + &quot; = VALUES(&quot; + PARENT_COLUMN + &quot;), &quot; + START_TIME_COLUMN + &quot; = VALUES(&quot; +
            START_TIME_COLUMN + &quot;), &quot; + END_TIME_COLUMN + &quot; = VALUES(&quot; + END_TIME_COLUMN + &quot;)&quot;;

    private static final String DIRECT_INSERT_H2 = &quot;MERGE INTO &quot; + RESOURCES_TABLE +
            &quot; (&quot; + PARENT_COLUMN + &quot;, &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;)&quot; +
            &quot; KEY (&quot; + FEDORA_ID_COLUMN + &quot;) VALUES (:parent, :child, :startTime, :endTime)&quot;;

<span class="nc" id="L192">    private static final Map&lt;DbPlatform, String&gt; DIRECT_UPSERT_MAPPING = Map.of(</span>
        DbPlatform.H2, DIRECT_INSERT_H2,
        DbPlatform.MYSQL, DIRECT_INSERT_RECORDS + DIRECT_INSERT_MYSQL_MARIA,
        DbPlatform.MARIADB, DIRECT_INSERT_RECORDS + DIRECT_INSERT_MYSQL_MARIA,
        DbPlatform.POSTGRESQL, DIRECT_INSERT_RECORDS + DIRECT_INSERT_POSTGRESQL
    );

    private static final String DIRECT_PURGE = &quot;DELETE FROM containment WHERE fedora_id = :child&quot;;

    /*
     * Remove an insert row from the transaction operation table for this parent child relationship.
     */
    private static final String UNDO_INSERT_CHILD_IN_TRANSACTION = &quot;DELETE FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :parent AND &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN
            + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'add'&quot;;

    /*
     * Remove a mark as deleted row from the transaction operation table for this child relationship (no parent).
     */
    private static final String UNDO_DELETE_CHILD_IN_TRANSACTION_NO_PARENT = &quot;DELETE FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN
            + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'delete'&quot;;

    /*
     * Is this parent child relationship being added in this transaction?
     */
    private static final String IS_CHILD_ADDED_IN_TRANSACTION = &quot;SELECT TRUE FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + PARENT_COLUMN + &quot; = :parent&quot; +
            &quot; AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'add'&quot;;

    /*
     * Is this child's relationship being marked for deletion in this transaction (no parent)?
     */
    private static final String IS_CHILD_DELETED_IN_TRANSACTION_NO_PARENT = &quot;SELECT TRUE FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child &quot; +
            &quot; AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'delete'&quot;;

   /*
    * Delete all rows from the transaction operation table for this transaction.
    */
    private static final String DELETE_ENTIRE_TRANSACTION = &quot;DELETE FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot;;

    /*
     * Add to the main table all rows from the transaction operation table marked 'add' for this transaction.
     */
    private static final String COMMIT_ADD_RECORDS_POSTGRESQL = &quot;INSERT INTO &quot; + RESOURCES_TABLE +
            &quot; ( &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;) &quot; +
            &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN +
            &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + OPERATION_COLUMN + &quot; = 'add' AND &quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId ON CONFLICT ( &quot; +  FEDORA_ID_COLUMN + &quot; )&quot; +
            &quot; DO UPDATE SET &quot; + PARENT_COLUMN + &quot; = EXCLUDED.&quot; + PARENT_COLUMN + &quot;, &quot; +
            START_TIME_COLUMN + &quot; = EXCLUDED.&quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot; = EXCLUDED.&quot; +
            END_TIME_COLUMN;

    private static final String COMMIT_ADD_RECORDS_MYSQL_MARIA = &quot;INSERT INTO &quot; + RESOURCES_TABLE +
            &quot; (&quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;) &quot; +
            &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN +
            &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + OPERATION_COLUMN + &quot; = 'add' AND &quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId ON DUPLICATE KEY UPDATE &quot; +
            PARENT_COLUMN + &quot; = VALUES(&quot; + PARENT_COLUMN + &quot;), &quot; + START_TIME_COLUMN + &quot; = VALUES(&quot; +
            START_TIME_COLUMN + &quot;), &quot; + END_TIME_COLUMN + &quot; = VALUES(&quot; + END_TIME_COLUMN + &quot;)&quot;;

    private static final String COMMIT_ADD_RECORDS_H2 = &quot;MERGE INTO &quot; + RESOURCES_TABLE +
            &quot; (&quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; + START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot;) &quot; +
            &quot;KEY (&quot; + FEDORA_ID_COLUMN + &quot;) SELECT &quot; + FEDORA_ID_COLUMN + &quot;, &quot; + PARENT_COLUMN + &quot;, &quot; +
            START_TIME_COLUMN + &quot;, &quot; + END_TIME_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; +
            OPERATION_COLUMN + &quot; = 'add' AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot;;

<span class="nc" id="L261">    private static final Map&lt;DbPlatform, String&gt; COMMIT_ADD_RECORDS_MAP = Map.of(</span>
            DbPlatform.H2, COMMIT_ADD_RECORDS_H2,
            DbPlatform.MYSQL, COMMIT_ADD_RECORDS_MYSQL_MARIA,
            DbPlatform.MARIADB, COMMIT_ADD_RECORDS_MYSQL_MARIA,
            DbPlatform.POSTGRESQL, COMMIT_ADD_RECORDS_POSTGRESQL
    );

    /*
     * Add an end time to the rows in the main table that match all rows from transaction operation table marked
     * 'delete' for this transaction.
     */
    private static final String COMMIT_DELETE_RECORDS_H2 = &quot;UPDATE &quot; + RESOURCES_TABLE +
            &quot; r SET r.&quot; + END_TIME_COLUMN + &quot; = ( SELECT t.&quot; + END_TIME_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; t &quot; +
            &quot; WHERE t.&quot; + FEDORA_ID_COLUMN + &quot; = r.&quot; + FEDORA_ID_COLUMN + &quot; AND t.&quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId AND t.&quot; +  OPERATION_COLUMN +
            &quot; = 'delete' AND t.&quot; + PARENT_COLUMN + &quot; = r.&quot; + PARENT_COLUMN + &quot; AND r.&quot; +
            END_TIME_COLUMN + &quot; IS NULL)&quot; +
            &quot; WHERE EXISTS (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; t WHERE t.&quot; + FEDORA_ID_COLUMN +
            &quot; = r.&quot; + FEDORA_ID_COLUMN + &quot; AND t.&quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND t.&quot; +
            OPERATION_COLUMN + &quot; = 'delete' AND t.&quot; + PARENT_COLUMN + &quot; = r.&quot; + PARENT_COLUMN + &quot; AND r.&quot; +
            END_TIME_COLUMN + &quot; IS NULL)&quot;;

    private static final String COMMIT_DELETE_RECORDS_MYSQL = &quot;UPDATE &quot; + RESOURCES_TABLE +
            &quot; r INNER JOIN &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; t ON t.&quot; + FEDORA_ID_COLUMN + &quot; = r.&quot; +
            FEDORA_ID_COLUMN + &quot; SET r.&quot; + END_TIME_COLUMN + &quot; = t.&quot; + END_TIME_COLUMN +
            &quot; WHERE t.&quot; + PARENT_COLUMN + &quot; = r.&quot; +
            PARENT_COLUMN + &quot; AND t.&quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND t.&quot; +  OPERATION_COLUMN +
            &quot; = 'delete' AND r.&quot; + END_TIME_COLUMN + &quot; IS NULL&quot;;

    private static final String COMMIT_DELETE_RECORDS_POSTGRES = &quot;UPDATE &quot; + RESOURCES_TABLE + &quot; SET &quot; +
            END_TIME_COLUMN + &quot; = t.&quot; + END_TIME_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; t WHERE t.&quot; +
            FEDORA_ID_COLUMN + &quot; = &quot; + RESOURCES_TABLE + &quot;.&quot; + FEDORA_ID_COLUMN + &quot; AND t.&quot; + PARENT_COLUMN +
            &quot; = &quot; + RESOURCES_TABLE + &quot;.&quot; + PARENT_COLUMN + &quot; AND t.&quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId AND t.&quot; + OPERATION_COLUMN + &quot; = 'delete' AND &quot; + RESOURCES_TABLE + &quot;.&quot; +
            END_TIME_COLUMN + &quot; IS NULL&quot;;

<span class="nc" id="L298">    private final Map&lt;DbPlatform, String&gt; COMMIT_DELETE_RECORDS = Map.of(</span>
            DbPlatform.H2, COMMIT_DELETE_RECORDS_H2,
            DbPlatform.MARIADB, COMMIT_DELETE_RECORDS_MYSQL,
            DbPlatform.MYSQL, COMMIT_DELETE_RECORDS_MYSQL,
            DbPlatform.POSTGRESQL, COMMIT_DELETE_RECORDS_POSTGRES
    );

    /*
     * Remove from the main table all rows from transaction operation table marked 'purge' for this transaction.
     */
    private static final String COMMIT_PURGE_RECORDS = &quot;DELETE FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; +
            &quot;EXISTS (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; t WHERE t.&quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId AND t.&quot; +  OPERATION_COLUMN + &quot; = 'purge' AND&quot; +
            &quot; t.&quot; + FEDORA_ID_COLUMN + &quot; = &quot; + RESOURCES_TABLE + &quot;.&quot; + FEDORA_ID_COLUMN +
            &quot; AND t.&quot; + PARENT_COLUMN + &quot; = &quot; + RESOURCES_TABLE + &quot;.&quot; + PARENT_COLUMN + &quot;)&quot;;

    /*
     * Query if a resource exists in the main table and is not deleted.
     */
    private static final String RESOURCE_EXISTS = &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + END_TIME_COLUMN + &quot; IS NULL&quot;;

    /*
     * Resource exists as a record in the transaction operations table with an 'add' operation and not also
     * exists as a 'delete' operation.
     */
    private static final String RESOURCE_EXISTS_IN_TRANSACTION = &quot;SELECT x.&quot; + FEDORA_ID_COLUMN + &quot; FROM&quot; +
            &quot; (SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot; +
            &quot;  AND &quot; + END_TIME_COLUMN + &quot; IS NULL UNION SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId&quot; + &quot; AND &quot; + OPERATION_COLUMN + &quot; = 'add') x WHERE NOT EXISTS &quot; +
            &quot; (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot; +
            &quot; AND &quot; + OPERATION_COLUMN + &quot; IN ('delete', 'purge'))&quot;;

    /*
     * Query if a resource exists in the main table even if it is deleted.
     */
    private static final String RESOURCE_OR_TOMBSTONE_EXISTS = &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; +
            RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot;;

    /*
     * Resource exists as a record in the main table even if deleted or in the transaction operations table with an
     * 'add' operation and not also exists as a 'delete' operation.
     */
    private static final String RESOURCE_OR_TOMBSTONE_EXISTS_IN_TRANSACTION = &quot;SELECT x.&quot; + FEDORA_ID_COLUMN + &quot; FROM&quot; +
            &quot; (SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot; +
            &quot; UNION SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId&quot; + &quot; AND &quot; + OPERATION_COLUMN + &quot; = 'add') x WHERE NOT EXISTS &quot; +
            &quot; (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot; +
            &quot; AND &quot; + OPERATION_COLUMN + &quot; IN ('delete', 'purge'))&quot;;


    /*
     * Get the parent ID for this resource from the main table if not deleted.
     */
    private static final String PARENT_EXISTS = &quot;SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + END_TIME_COLUMN + &quot; IS NULL&quot;;

    /*
     * Get the parent ID for this resource from the operations table for an 'add' operation in this transaction, but
     * exclude any 'delete' operations for this resource in this transaction.
     */
    private static final String PARENT_EXISTS_IN_TRANSACTION = &quot;SELECT x.&quot; + PARENT_COLUMN + &quot; FROM&quot; +
            &quot; (SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot; +
            &quot; AND &quot; + END_TIME_COLUMN + &quot; IS NULL&quot; +
            &quot; UNION SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot; +
            &quot; AND &quot; + OPERATION_COLUMN + &quot; = 'add') x&quot; +
            &quot; WHERE NOT EXISTS &quot; +
            &quot; (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId&quot; +
            &quot; AND &quot; + OPERATION_COLUMN + &quot; = 'delete')&quot;;

    /*
     * Get the parent ID for this resource from the main table if deleted.
     */
    private static final String PARENT_EXISTS_DELETED = &quot;SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + END_TIME_COLUMN + &quot; IS NOT NULL&quot;;

    /*
     * Get the parent ID for this resource from main table and the operations table for a 'delete' operation in this
     * transaction, excluding any 'add' operations for this resource in this transaction.
     */
    private static final String PARENT_EXISTS_DELETED_IN_TRANSACTION = &quot;SELECT x.&quot; + PARENT_COLUMN + &quot; FROM&quot; +
            &quot; (SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot; +
            &quot; AND &quot; + END_TIME_COLUMN + &quot; IS NOT NULL UNION SELECT &quot; + PARENT_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'delete') x WHERE NOT EXISTS &quot; +
            &quot; (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'add')&quot;;

    /*
     * Does this resource exist in the transaction operation table for an 'add' record.
     */
    private static final String IS_CHILD_ADDED_IN_TRANSACTION_NO_PARENT = &quot;SELECT TRUE FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; +
            TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'add'&quot;;

    /*
     * Delete a row from the transaction operation table with this resource and 'add' operation, no parent required.
     */
    private static final String UNDO_INSERT_CHILD_IN_TRANSACTION_NO_PARENT = &quot;DELETE FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child AND &quot; + TRANSACTION_ID_COLUMN
            + &quot; = :transactionId AND &quot; + OPERATION_COLUMN + &quot; = 'add'&quot;;

    private static final String TRUNCATE_TABLE = &quot;TRUNCATE TABLE &quot;;

    /*
     * Any record tracked in the containment index is either active or a tombstone. Either way it exists for the
     * purpose of finding ghost nodes.
     */
    private static final String SELECT_ID_LIKE = &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; +
            FEDORA_ID_COLUMN + &quot; LIKE :resourceId&quot;;

    private static final String SELECT_ID_LIKE_IN_TRANSACTION = &quot;SELECT x.&quot; + FEDORA_ID_COLUMN + &quot; FROM (SELECT &quot; +
            FEDORA_ID_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; LIKE :resourceId&quot; +
            &quot; UNION SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; +
            FEDORA_ID_COLUMN + &quot; LIKE :resourceId AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'add') x WHERE NOT EXISTS (SELECT 1 FROM &quot; + TRANSACTION_OPERATIONS_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; LIKE :resourceId AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'delete')&quot;;

    private static final String SELECT_LAST_UPDATED = &quot;SELECT &quot; + UPDATED_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :resourceId&quot;;

    private static final String UPDATE_LAST_UPDATED = &quot;UPDATE &quot; + RESOURCES_TABLE + &quot; SET &quot; + UPDATED_COLUMN +
            &quot; = :updated WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :resourceId&quot;;

    private static final String CONDITIONALLY_UPDATE_LAST_UPDATED = &quot;UPDATE &quot; + RESOURCES_TABLE +
            &quot; SET &quot; + UPDATED_COLUMN + &quot; = :updated WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :resourceId&quot; +
            &quot; AND (&quot; + UPDATED_COLUMN + &quot; IS NULL OR &quot; + UPDATED_COLUMN + &quot; &lt; :updated)&quot;;

    private static final String SELECT_LAST_UPDATED_IN_TX = &quot;SELECT MAX(x.updated)&quot; +
            &quot; FROM (SELECT &quot; + UPDATED_COLUMN + &quot; as updated FROM &quot; + RESOURCES_TABLE + &quot; WHERE &quot; +
            FEDORA_ID_COLUMN + &quot; = :resourceId UNION SELECT &quot; + START_TIME_COLUMN +
            &quot; as updated FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :resourceId AND &quot; +
            OPERATION_COLUMN + &quot; = 'add' AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId UNION SELECT &quot; +
            END_TIME_COLUMN + &quot; as updated FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + PARENT_COLUMN +
            &quot; = :resourceId AND &quot; + OPERATION_COLUMN + &quot; = 'delete' AND &quot; + TRANSACTION_ID_COLUMN +
            &quot; = :transactionId UNION SELECT &quot; + END_TIME_COLUMN +
            &quot; as updated FROM &quot; + TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + PARENT_COLUMN + &quot; = :resourceId AND &quot; +
            OPERATION_COLUMN + &quot; = 'add' AND &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId) x&quot;;

    private static final String GET_UPDATED_RESOURCES = &quot;SELECT DISTINCT &quot; + PARENT_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; in ('add', 'delete')&quot;;

    /*
     * Get the startTime for the specified resource from the main table, if it exists.
     */
    private static final String GET_START_TIME = &quot;SELECT &quot; + START_TIME_COLUMN + &quot; FROM &quot; + RESOURCES_TABLE +
            &quot; WHERE &quot; + FEDORA_ID_COLUMN + &quot; = :child&quot;;

    /*
     * Get all resources deleted in this transaction
     */
    private static final String GET_DELETED_RESOURCES = &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'delete'&quot;;

    /*
     * Get all resources added in this transaction
     */
    private static final String GET_ADDED_RESOURCES = &quot;SELECT &quot; + FEDORA_ID_COLUMN + &quot; FROM &quot; +
            TRANSACTION_OPERATIONS_TABLE + &quot; WHERE &quot; + TRANSACTION_ID_COLUMN + &quot; = :transactionId AND &quot; +
            OPERATION_COLUMN + &quot; = 'add'&quot;;

    @Inject
    private FedoraPropsConfig fedoraPropsConfig;

    private Cache&lt;String, String&gt; getContainedByCache;

    private Cache&lt;String, Boolean&gt; resourceExistsCache;

    /**
     * Connect to the database
     */
    @PostConstruct
    private void setup() {
<span class="nc" id="L480">        jdbcTemplate = getNamedParameterJdbcTemplate();</span>
<span class="nc" id="L481">        dbPlatform = DbPlatform.fromDataSource(dataSource);</span>
<span class="nc" id="L482">        this.getContainedByCache = Caffeine.newBuilder()</span>
<span class="nc" id="L483">                .maximumSize(fedoraPropsConfig.getContainmentCacheSize())</span>
<span class="nc" id="L484">                .expireAfterAccess(fedoraPropsConfig.getContainmentCacheTimeout(), TimeUnit.MINUTES)</span>
<span class="nc" id="L485">                .build();</span>
<span class="nc" id="L486">        this.resourceExistsCache = Caffeine.newBuilder()</span>
<span class="nc" id="L487">                .maximumSize(fedoraPropsConfig.getContainmentCacheSize())</span>
<span class="nc" id="L488">                .expireAfterAccess(fedoraPropsConfig.getContainmentCacheTimeout(), TimeUnit.MINUTES)</span>
<span class="nc" id="L489">                .build();</span>
<span class="nc" id="L490">    }</span>

    private NamedParameterJdbcTemplate getNamedParameterJdbcTemplate() {
<span class="nc" id="L493">        return new NamedParameterJdbcTemplate(getDataSource());</span>
    }

    void setContainsLimit(final int limit) {
<span class="nc" id="L497">        containsLimit = limit;</span>
<span class="nc" id="L498">    }</span>

    @Override
    public Stream&lt;String&gt; getContains(@Nonnull final Transaction tx, final FedoraId fedoraId) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">        final String resourceId = fedoraId.isMemento() ? fedoraId.getBaseId() : fedoraId.getFullId();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        final Instant asOfTime = fedoraId.isMemento() ? fedoraId.getMementoInstant() : null;</span>
<span class="nc" id="L504">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L505">        parameterSource.addValue(&quot;parent&quot;, resourceId);</span>

<span class="nc" id="L507">        LOGGER.debug(&quot;getContains for {} in transaction {} and instant {}&quot;, resourceId, tx, asOfTime);</span>

        final String query;
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (asOfTime == null) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (tx.isOpenLongRunning()) {</span>
                // we are in a transaction
<span class="nc" id="L513">                parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L514">                query = SELECT_CHILDREN_IN_TRANSACTION;</span>
            } else {
                // not in a transaction
<span class="nc" id="L517">                query = SELECT_CHILDREN;</span>
            }
        } else {
<span class="nc" id="L520">            parameterSource.addValue(&quot;asOfTime&quot;, formatInstant(asOfTime));</span>
<span class="nc" id="L521">            query = SELECT_CHILDREN_OF_MEMENTO;</span>
        }

<span class="nc" id="L524">        return StreamSupport.stream(new ContainmentIterator(query, parameterSource), false);</span>
    }

    @Override
    public Stream&lt;String&gt; getContainsDeleted(@Nonnull final Transaction tx, final FedoraId fedoraId) {
<span class="nc" id="L529">        final String resourceId = fedoraId.getFullId();</span>
<span class="nc" id="L530">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L531">        parameterSource.addValue(&quot;parent&quot;, resourceId);</span>

        final String query;
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
            // we are in a transaction
<span class="nc" id="L536">            parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L537">            query = SELECT_DELETED_CHILDREN_IN_TRANSACTION;</span>
        } else {
            // not in a transaction
<span class="nc" id="L540">            query = SELECT_DELETED_CHILDREN;</span>
        }
<span class="nc" id="L542">        LOGGER.debug(&quot;getContainsDeleted for {} in transaction {}&quot;, resourceId, tx);</span>
<span class="nc" id="L543">        return StreamSupport.stream(new ContainmentIterator(query, parameterSource), false);</span>
    }

    @Override
    public String getContainedBy(@Nonnull final Transaction tx, final FedoraId resource) {
<span class="nc" id="L548">        final String resourceID = resource.getFullId();</span>
        final String parentID;
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
<span class="nc" id="L551">            parentID = jdbcTemplate.queryForList(PARENT_EXISTS_IN_TRANSACTION, Map.of(&quot;child&quot;, resourceID,</span>
<span class="nc" id="L552">                    &quot;transactionId&quot;, tx.getId()), String.class).stream().findFirst().orElse(null);</span>
        } else {
<span class="nc" id="L554">            parentID = this.getContainedByCache.get(resourceID, key -&gt;</span>
<span class="nc" id="L555">                    jdbcTemplate.queryForList(PARENT_EXISTS, Map.of(&quot;child&quot;, key), String.class).stream()</span>
<span class="nc" id="L556">                    .findFirst().orElse(null)</span>
            );
        }
<span class="nc" id="L559">        return parentID;</span>
    }

    @Override
    public void addContainedBy(@Nonnull final Transaction tx, final FedoraId parent, final FedoraId child) {
<span class="nc" id="L564">        addContainedBy(tx, parent, child, Instant.now(), null);</span>
<span class="nc" id="L565">    }</span>

    @Override
    public void addContainedBy(@Nonnull final Transaction tx, final FedoraId parent, final FedoraId child,
                               final Instant startTime, final Instant endTime) {
<span class="nc" id="L570">        tx.doInTx(() -&gt; {</span>
<span class="nc" id="L571">            final String parentID = parent.getFullId();</span>
<span class="nc" id="L572">            final String childID = child.getFullId();</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="nc" id="L575">                LOGGER.debug(&quot;Adding: parent: {}, child: {}, in txn: {}, start time {}, end time {}&quot;, parentID, childID,</span>
<span class="nc" id="L576">                        tx.getId(), formatInstant(startTime), formatInstant(endTime));</span>
<span class="nc" id="L577">                doUpsert(tx, parentID, childID, startTime, endTime, &quot;add&quot;);</span>
            } else {
<span class="nc" id="L579">                LOGGER.debug(&quot;Adding: parent: {}, child: {}, start time {}, end time {}&quot;, parentID, childID,</span>
<span class="nc" id="L580">                        formatInstant(startTime), formatInstant(endTime));</span>
<span class="nc" id="L581">                doDirectUpsert(parentID, childID, startTime, endTime);</span>
            }
<span class="nc" id="L583">        });</span>
<span class="nc" id="L584">    }</span>

    @Override
    public void removeContainedBy(@Nonnull final Transaction tx, final FedoraId parent, final FedoraId child) {
<span class="nc" id="L588">        tx.doInTx(() -&gt; {</span>
<span class="nc" id="L589">            final String parentID = parent.getFullId();</span>
<span class="nc" id="L590">            final String childID = child.getFullId();</span>

<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="nc" id="L593">                final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L594">                parameterSource.addValue(&quot;parent&quot;, parentID);</span>
<span class="nc" id="L595">                parameterSource.addValue(&quot;child&quot;, childID);</span>
<span class="nc" id="L596">                parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L597">                final boolean addedInTxn = !jdbcTemplate.queryForList(IS_CHILD_ADDED_IN_TRANSACTION, parameterSource)</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                        .isEmpty();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                if (addedInTxn) {</span>
<span class="nc" id="L600">                    jdbcTemplate.update(UNDO_INSERT_CHILD_IN_TRANSACTION, parameterSource);</span>
                } else {
<span class="nc" id="L602">                    doUpsert(tx, parentID, childID, null, Instant.now(), &quot;delete&quot;);</span>
                }
<span class="nc" id="L604">            } else {</span>
<span class="nc" id="L605">                doDirectUpsert(parentID, childID, null, Instant.now());</span>
<span class="nc" id="L606">                this.getContainedByCache.invalidate(childID);</span>
            }
<span class="nc" id="L608">        });</span>
<span class="nc" id="L609">    }</span>

    @Override
    public void removeResource(@Nonnull final Transaction tx, final FedoraId resource) {
<span class="nc" id="L613">        tx.doInTx(() -&gt; {</span>
<span class="nc" id="L614">            final String resourceID = resource.getFullId();</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (!tx.isShortLived()) {</span>
<span class="nc" id="L617">                final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L618">                parameterSource.addValue(&quot;child&quot;, resourceID);</span>
<span class="nc" id="L619">                parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L620">                final boolean addedInTxn = !jdbcTemplate.queryForList(IS_CHILD_ADDED_IN_TRANSACTION_NO_PARENT,</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                        parameterSource).isEmpty();</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (addedInTxn) {</span>
<span class="nc" id="L623">                    jdbcTemplate.update(UNDO_INSERT_CHILD_IN_TRANSACTION_NO_PARENT, parameterSource);</span>
                } else {
<span class="nc" id="L625">                    final String parent = getContainedBy(tx, resource);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc" id="L627">                        LOGGER.debug(&quot;Marking containment relationship between parent ({}) and child ({}) deleted&quot;,</span>
                                parent, resourceID);
<span class="nc" id="L629">                        doUpsert(tx, parent, resourceID, null, Instant.now(), &quot;delete&quot;);</span>
                    }
                }
<span class="nc" id="L632">            } else {</span>
<span class="nc" id="L633">                final String parent = getContainedBy(tx, resource);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L635">                    LOGGER.debug(&quot;Marking containment relationship between parent ({}) and child ({}) deleted&quot;, parent,</span>
                            resourceID);
<span class="nc" id="L637">                    doDirectUpsert(parent, resourceID, null, Instant.now());</span>
<span class="nc" id="L638">                    this.getContainedByCache.invalidate(resourceID);</span>
                }
            }
<span class="nc" id="L641">        });</span>
<span class="nc" id="L642">    }</span>

    @Override
    public void purgeResource(@Nonnull final Transaction tx, final FedoraId resource) {
<span class="nc" id="L646">        tx.doInTx(() -&gt; {</span>
<span class="nc" id="L647">            final String resourceID = resource.getFullId();</span>

<span class="nc" id="L649">            final String parent = getContainedByDeleted(tx, resource);</span>

<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L652">                LOGGER.debug(&quot;Removing containment relationship between parent ({}) and child ({})&quot;,</span>
                        parent, resourceID);

<span class="nc bnc" id="L655" title="All 2 branches missed.">                if (!tx.isShortLived()) {</span>
<span class="nc" id="L656">                    doUpsert(tx, parent, resourceID, null, null, &quot;purge&quot;);</span>
                } else {
<span class="nc" id="L658">                    final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L659">                    parameterSource.addValue(&quot;child&quot;, resourceID);</span>
<span class="nc" id="L660">                    jdbcTemplate.update(DIRECT_PURGE, parameterSource);</span>
                }
            }
<span class="nc" id="L663">        });</span>
<span class="nc" id="L664">    }</span>

    /**
     * Do the Upsert action to the transaction table.
     * @param tx the transaction
     * @param parentId the containing resource id
     * @param resourceId the contained resource id
     * @param startTime the instant the relationship started, if null get the current time from the main table.
     * @param endTime the instant the relationship ended or null for none.
     * @param operation the operation to perform.
     */
    private void doUpsert(final Transaction tx, final String parentId, final String resourceId, final Instant startTime,
                          final Instant endTime, final String operation) {
<span class="nc" id="L677">        final var parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L678">        parameterSource.addValue(&quot;child&quot;, resourceId);</span>
<span class="nc" id="L679">        parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L680">        parameterSource.addValue(&quot;parent&quot;, parentId);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (startTime == null) {</span>
<span class="nc" id="L682">            parameterSource.addValue(&quot;startTime&quot;, formatInstant(getCurrentStartTime(resourceId)));</span>
        } else {
<span class="nc" id="L684">            parameterSource.addValue(&quot;startTime&quot;, formatInstant(startTime));</span>
        }
<span class="nc" id="L686">        parameterSource.addValue(&quot;endTime&quot;, formatInstant(endTime));</span>
<span class="nc" id="L687">        parameterSource.addValue(&quot;operation&quot;, operation);</span>
<span class="nc" id="L688">        jdbcTemplate.update(UPSERT_MAPPING.get(dbPlatform), parameterSource);</span>
<span class="nc" id="L689">    }</span>

    /**
     * Do the Upsert directly to the containment index; not the tx table
     *
     * @param parentId the containing resource id
     * @param resourceId the contained resource id
     * @param startTime the instant the relationship started, if null get the current time from the main table.
     * @param endTime the instant the relationship ended or null for none.
     */
    private void doDirectUpsert(final String parentId, final String resourceId, final Instant startTime,
                                final Instant endTime) {
<span class="nc" id="L701">        final var parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L702">        parameterSource.addValue(&quot;child&quot;, resourceId);</span>
<span class="nc" id="L703">        parameterSource.addValue(&quot;parent&quot;, parentId);</span>
<span class="nc" id="L704">        parameterSource.addValue(&quot;endTime&quot;, formatInstant(endTime));</span>

        final String query;

<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (startTime == null) {</span>
            // This the case for an update
<span class="nc" id="L710">            query = DIRECT_UPDATE_END_TIME;</span>
        } else {
            // This is the case for a new record
<span class="nc" id="L713">            parameterSource.addValue(&quot;startTime&quot;, formatInstant(startTime));</span>
<span class="nc" id="L714">            query = DIRECT_UPSERT_MAPPING.get(dbPlatform);</span>
        }

<span class="nc" id="L717">        jdbcTemplate.update(query, parameterSource);</span>
<span class="nc" id="L718">        updateParentTimestamp(parentId, startTime, endTime);</span>
<span class="nc" id="L719">        resourceExistsCache.invalidate(resourceId);</span>
<span class="nc" id="L720">    }</span>

    private void updateParentTimestamp(final String parentId, final Instant startTime, final Instant endTime) {
<span class="nc" id="L723">        final var parameterSource = new MapSqlParameterSource();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        final var updated = endTime == null ? startTime : endTime;</span>
<span class="nc" id="L725">        parameterSource.addValue(&quot;resourceId&quot;, parentId);</span>
<span class="nc" id="L726">        parameterSource.addValue(&quot;updated&quot;, formatInstant(updated));</span>
<span class="nc" id="L727">        jdbcTemplate.update(CONDITIONALLY_UPDATE_LAST_UPDATED, parameterSource);</span>
<span class="nc" id="L728">    }</span>

    /**
     * Find parent for a resource using a deleted containment relationship.
     * @param tx the transaction.
     * @param resource the child resource id.
     * @return the parent id.
     */
    private String getContainedByDeleted(final Transaction tx, final FedoraId resource) {
<span class="nc" id="L737">        final String resourceID = resource.getFullId();</span>
<span class="nc" id="L738">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L739">        parameterSource.addValue(&quot;child&quot;, resourceID);</span>
        final List&lt;String&gt; parentID;
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
<span class="nc" id="L742">            parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L743">            parentID = jdbcTemplate.queryForList(PARENT_EXISTS_DELETED_IN_TRANSACTION, parameterSource, String.class);</span>
        } else {
<span class="nc" id="L745">            parentID = jdbcTemplate.queryForList(PARENT_EXISTS_DELETED, parameterSource, String.class);</span>
        }
<span class="nc" id="L747">        return parentID.stream().findFirst().orElse(null);</span>
    }

    @Override
    public void commitTransaction(final Transaction tx) {
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (!tx.isShortLived()) {</span>
<span class="nc" id="L753">            tx.ensureCommitting();</span>
            try {
<span class="nc" id="L755">                final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L756">                parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L757">                final List&lt;String&gt; changedParents = jdbcTemplate.queryForList(GET_UPDATED_RESOURCES, parameterSource,</span>
                        String.class);
<span class="nc" id="L759">                final List&lt;String&gt; removedResources = jdbcTemplate.queryForList(GET_DELETED_RESOURCES, parameterSource,</span>
                        String.class);
<span class="nc" id="L761">                final List&lt;String&gt; addedResources = jdbcTemplate.queryForList(GET_ADDED_RESOURCES, parameterSource,</span>
                        String.class);
<span class="nc" id="L763">                final int purged = jdbcTemplate.update(COMMIT_PURGE_RECORDS, parameterSource);</span>
<span class="nc" id="L764">                final int deleted = jdbcTemplate.update(COMMIT_DELETE_RECORDS.get(dbPlatform), parameterSource);</span>
<span class="nc" id="L765">                final int added = jdbcTemplate.update(COMMIT_ADD_RECORDS_MAP.get(dbPlatform), parameterSource);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                for (final var parent : changedParents) {</span>
<span class="nc" id="L767">                    final var updated = jdbcTemplate.queryForObject(SELECT_LAST_UPDATED_IN_TX,</span>
<span class="nc" id="L768">                            Map.of(&quot;resourceId&quot;, parent, &quot;transactionId&quot;, tx.getId()), Timestamp.class);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                    if (updated != null) {</span>
<span class="nc" id="L770">                        jdbcTemplate.update(UPDATE_LAST_UPDATED,</span>
<span class="nc" id="L771">                                Map.of(&quot;resourceId&quot;, parent, &quot;updated&quot;, updated));</span>
                    }
<span class="nc" id="L773">                }</span>
<span class="nc" id="L774">                jdbcTemplate.update(DELETE_ENTIRE_TRANSACTION, parameterSource);</span>
<span class="nc" id="L775">                this.getContainedByCache.invalidateAll(removedResources);</span>
                // Add inserted records to removed records list.
<span class="nc" id="L777">                removedResources.addAll(addedResources);</span>
<span class="nc" id="L778">                this.resourceExistsCache.invalidateAll(removedResources);</span>
<span class="nc" id="L779">                LOGGER.debug(&quot;Commit of tx {} complete with {} adds, {} deletes and {} purges&quot;,</span>
<span class="nc" id="L780">                        tx.getId(), added, deleted, purged);</span>
<span class="nc" id="L781">            } catch (final Exception e) {</span>
<span class="nc" id="L782">                LOGGER.warn(&quot;Unable to commit containment index transaction {}: {}&quot;, tx, e.getMessage());</span>
<span class="nc" id="L783">                throw new RepositoryRuntimeException(&quot;Unable to commit containment index transaction&quot;, e);</span>
<span class="nc" id="L784">            }</span>
        }
<span class="nc" id="L786">    }</span>

    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    @Override
    public void rollbackTransaction(final Transaction tx) {
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (!tx.isShortLived()) {</span>
<span class="nc" id="L792">            final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L793">            parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L794">            jdbcTemplate.update(DELETE_ENTIRE_TRANSACTION, parameterSource);</span>
        }
<span class="nc" id="L796">    }</span>

    @Override
    public boolean resourceExists(@Nonnull final Transaction tx, final FedoraId fedoraId,
                                  final boolean includeDeleted) {
        // Get the containing ID because fcr:metadata will not exist here but MUST exist if the containing resource does
<span class="nc" id="L802">        final String resourceId = fedoraId.getBaseId();</span>
<span class="nc" id="L803">        LOGGER.debug(&quot;Checking if {} exists in transaction {}&quot;, resourceId, tx);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (fedoraId.isRepositoryRoot()) {</span>
            // Root always exists.
<span class="nc" id="L806">            return true;</span>
        }
<span class="nc bnc" id="L808" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            final var queryToUse = includeDeleted ? RESOURCE_OR_TOMBSTONE_EXISTS_IN_TRANSACTION :</span>
<span class="nc" id="L810">                    RESOURCE_EXISTS_IN_TRANSACTION;</span>
<span class="nc" id="L811">            return !jdbcTemplate.queryForList(queryToUse,</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                    Map.of(&quot;child&quot;, resourceId, &quot;transactionId&quot;, tx.getId()), String.class).isEmpty();</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        } else if (includeDeleted) {</span>
<span class="nc" id="L814">            final Boolean exists = resourceExistsCache.getIfPresent(resourceId);</span>
<span class="nc bnc" id="L815" title="All 4 branches missed.">            if (exists != null &amp;&amp; exists) {</span>
                // Only return true, false values might change once deleted resources are included.
<span class="nc" id="L817">                return true;</span>
            }
<span class="nc" id="L819">            return !jdbcTemplate.queryForList(RESOURCE_OR_TOMBSTONE_EXISTS,</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                    Map.of(&quot;child&quot;, resourceId), String.class).isEmpty();</span>
        } else {
<span class="nc" id="L822">            return resourceExistsCache.get(resourceId, key -&gt; !jdbcTemplate.queryForList(RESOURCE_EXISTS,</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                        Map.of(&quot;child&quot;, resourceId), String.class).isEmpty()</span>
            );
        }
    }

    @Override
    public FedoraId getContainerIdByPath(final Transaction tx, final FedoraId fedoraId, final boolean checkDeleted) {
<span class="nc bnc" id="L830" title="All 2 branches missed.">        if (fedoraId.isRepositoryRoot()) {</span>
            // If we are root then we are the top.
<span class="nc" id="L832">            return fedoraId;</span>
        }
<span class="nc" id="L834">        final String parent = getContainedBy(tx, fedoraId);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L836">            return FedoraId.create(parent);</span>
        }
<span class="nc" id="L838">        String fullId = fedoraId.getFullId();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        while (fullId.contains(&quot;/&quot;)) {</span>
<span class="nc" id="L840">            fullId = fedoraId.getResourceId().substring(0, fullId.lastIndexOf(&quot;/&quot;));</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (fullId.equals(FEDORA_ID_PREFIX)) {</span>
<span class="nc" id="L842">                return FedoraId.getRepositoryRootId();</span>
            }
<span class="nc" id="L844">            final FedoraId testID = FedoraId.create(fullId);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">            if (resourceExists(tx, testID, checkDeleted)) {</span>
<span class="nc" id="L846">                return testID;</span>
            }
<span class="nc" id="L848">        }</span>
<span class="nc" id="L849">        return FedoraId.getRepositoryRootId();</span>
    }

    @Override
    public void reset() {
        try {
<span class="nc" id="L855">            jdbcTemplate.update(TRUNCATE_TABLE + RESOURCES_TABLE, Collections.emptyMap());</span>
<span class="nc" id="L856">            jdbcTemplate.update(TRUNCATE_TABLE + TRANSACTION_OPERATIONS_TABLE, Collections.emptyMap());</span>
<span class="nc" id="L857">            this.getContainedByCache.invalidateAll();</span>
<span class="nc" id="L858">        } catch (final Exception e) {</span>
<span class="nc" id="L859">            throw new RepositoryRuntimeException(&quot;Failed to truncate containment tables&quot;, e);</span>
<span class="nc" id="L860">        }</span>
<span class="nc" id="L861">    }</span>

    @Override
    public boolean hasResourcesStartingWith(final Transaction tx, final FedoraId fedoraId) {
<span class="nc" id="L865">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L866">        parameterSource.addValue(&quot;resourceId&quot;, fedoraId.getFullId() + &quot;/%&quot;);</span>
        final boolean matchingIds;
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
<span class="nc" id="L869">            parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L870">            matchingIds = !jdbcTemplate.queryForList(SELECT_ID_LIKE_IN_TRANSACTION, parameterSource, String.class)</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                .isEmpty();</span>
        } else {
<span class="nc bnc" id="L873" title="All 2 branches missed.">            matchingIds = !jdbcTemplate.queryForList(SELECT_ID_LIKE, parameterSource, String.class).isEmpty();</span>
        }
<span class="nc" id="L875">        return matchingIds;</span>
    }

    @Override
    public Instant containmentLastUpdated(final Transaction tx, final FedoraId fedoraId) {
<span class="nc" id="L880">        final MapSqlParameterSource parameterSource = new MapSqlParameterSource();</span>
<span class="nc" id="L881">        parameterSource.addValue(&quot;resourceId&quot;, fedoraId.getFullId());</span>
        final String queryToUse;
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (tx.isOpenLongRunning()) {</span>
<span class="nc" id="L884">            parameterSource.addValue(&quot;transactionId&quot;, tx.getId());</span>
<span class="nc" id="L885">            queryToUse = SELECT_LAST_UPDATED_IN_TX;</span>
        } else {
<span class="nc" id="L887">            queryToUse = SELECT_LAST_UPDATED;</span>
        }
        try {
<span class="nc" id="L890">            return fromTimestamp(jdbcTemplate.queryForObject(queryToUse, parameterSource, Timestamp.class));</span>
<span class="nc" id="L891">        } catch (final EmptyResultDataAccessException e) {</span>
<span class="nc" id="L892">            return null;</span>
        }
    }

    /**
     * Get the data source backing this containment index
     * @return data source
     */
    public DataSource getDataSource() {
<span class="nc" id="L901">        return dataSource;</span>
    }

    /**
     * Set the data source backing this containment index
     * @param dataSource data source
     */
    public void setDataSource(final DataSource dataSource) {
<span class="nc" id="L909">        this.dataSource = dataSource;</span>
<span class="nc" id="L910">    }</span>

    /**
     * Get the current startTime for the resource
     * @param resourceId id of the resource
     * @return start time or null if no committed record.
     */
    private Instant getCurrentStartTime(final String resourceId) {
<span class="nc" id="L918">        return fromTimestamp(jdbcTemplate.queryForObject(GET_START_TIME, Map.of(</span>
                &quot;child&quot;, resourceId
        ), Timestamp.class));
    }

    private Instant fromTimestamp(final Timestamp timestamp) {
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (timestamp != null) {</span>
<span class="nc" id="L925">            return timestamp.toInstant();</span>
        }
<span class="nc" id="L927">        return null;</span>
    }

    /**
     * Format an instant to a timestamp without milliseconds, due to precision
     * issues with memento datetimes.
     * @param instant the instant to format.
     * @return the datetime timestamp
     */
    private Timestamp formatInstant(final Instant instant) {
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (instant == null) {</span>
<span class="nc" id="L938">            return null;</span>
        }
<span class="nc" id="L940">        return Timestamp.from(instant.truncatedTo(ChronoUnit.SECONDS));</span>
    }

    /**
     * Private class to back a stream with a paged DB query.
     *
     * If this needs to be run in parallel we will have to override trySplit() and determine a good method to split on.
     */
    private class ContainmentIterator extends Spliterators.AbstractSpliterator&lt;String&gt; {
<span class="nc" id="L949">        final Queue&lt;String&gt; children = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="nc" id="L950">        int numOffsets = 0;</span>
        final String queryToUse;
        final MapSqlParameterSource parameterSource;

<span class="nc" id="L954">        public ContainmentIterator(final String query, final MapSqlParameterSource parameters) {</span>
<span class="nc" id="L955">            super(Long.MAX_VALUE, Spliterator.ORDERED);</span>
<span class="nc" id="L956">            queryToUse = query;</span>
<span class="nc" id="L957">            parameterSource = parameters;</span>
<span class="nc" id="L958">            parameterSource.addValue(&quot;containsLimit&quot;, containsLimit);</span>
<span class="nc" id="L959">        }</span>

        @Override
        public boolean tryAdvance(final Consumer&lt;? super String&gt; action) {
            try {
<span class="nc" id="L964">                action.accept(children.remove());</span>
<span class="nc" id="L965">            } catch (final NoSuchElementException e) {</span>
<span class="nc" id="L966">                parameterSource.addValue(&quot;offSet&quot;, numOffsets * containsLimit);</span>
<span class="nc" id="L967">                numOffsets += 1;</span>
<span class="nc" id="L968">                children.addAll(jdbcTemplate.queryForList(queryToUse, parameterSource, String.class));</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (children.size() == 0) {</span>
                    // no more elements.
<span class="nc" id="L971">                    return false;</span>
                }
<span class="nc" id="L973">                action.accept(children.remove());</span>
<span class="nc" id="L974">            }</span>
<span class="nc" id="L975">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>